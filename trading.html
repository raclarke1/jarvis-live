<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trading Performance | Jarvis</title>
    <meta http-equiv="refresh" content="300">
    <style>
        :root {
            --bg-primary: #0a0a0f;
            --bg-secondary: #12121a;
            --bg-card: linear-gradient(135deg, #1a1a2e 0%, #16162a 100%);
            --text-primary: #e0e0e0;
            --text-secondary: #888;
            --accent-green: #00ff88;
            --accent-green-dim: rgba(0,255,136,0.15);
            --accent-red: #ff4757;
            --accent-red-dim: rgba(255,71,87,0.15);
            --accent-blue: #58a6ff;
            --accent-purple: #a855f7;
            --border-color: #2a2a4a;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            padding: 24px;
        }
        .container { max-width: 1400px; margin: 0 auto; }
        
        /* Header */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 32px;
        }
        .header h1 {
            font-size: 2rem;
            font-weight: 700;
            background: linear-gradient(135deg, #fff 0%, #888 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .header .subtitle { color: var(--text-secondary); margin-top: 4px; }
        .header .updated {
            color: var(--text-secondary);
            font-size: 0.875rem;
        }
        
        /* Strategy Cards Grid */
        .strategies-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 24px;
            margin-bottom: 32px;
        }
        
        /* Strategy Card */
        .strategy-card {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            padding: 24px;
        }
        .strategy-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 20px;
        }
        .strategy-name {
            font-size: 1.25rem;
            font-weight: 600;
        }
        .strategy-since {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-top: 4px;
        }
        .total-return {
            text-align: right;
        }
        .total-return .value {
            font-size: 2rem;
            font-weight: 700;
        }
        .total-return .value.positive { color: var(--accent-green); }
        .total-return .value.negative { color: var(--accent-red); }
        .total-return .label {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }
        
        /* Metrics Grid */
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 12px;
            margin-bottom: 20px;
        }
        .metric-card {
            background: rgba(255,255,255,0.03);
            border-radius: 8px;
            padding: 12px;
        }
        .metric-card .label {
            font-size: 0.7rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }
        .metric-card .value {
            font-size: 1.1rem;
            font-weight: 600;
        }
        .metric-card .value.positive { color: var(--accent-green); }
        .metric-card .value.negative { color: var(--accent-red); }
        
        /* Mini Stats */
        .mini-stats {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 8px;
            text-align: center;
            padding-top: 16px;
            border-top: 1px solid var(--border-color);
        }
        .mini-stat .label {
            font-size: 0.65rem;
            color: var(--text-secondary);
            text-transform: uppercase;
        }
        .mini-stat .value {
            font-size: 0.875rem;
            font-weight: 500;
        }
        
        /* Capital Progress */
        .capital-progress {
            display: flex;
            justify-content: space-between;
            padding-top: 16px;
            margin-top: 16px;
            border-top: 1px solid var(--border-color);
            font-size: 0.875rem;
        }
        .capital-progress .start { color: var(--text-secondary); }
        .capital-progress .arrow { color: var(--text-secondary); }
        .capital-progress .current { font-weight: 600; }
        
        /* Trade Log */
        .trade-log {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            overflow: hidden;
        }
        .trade-log-header {
            padding: 16px 20px;
            border-bottom: 1px solid var(--border-color);
        }
        .trade-log-header h2 {
            font-size: 1.1rem;
            font-weight: 600;
        }
        .trade-log-header .count {
            font-size: 0.875rem;
            color: var(--text-secondary);
            margin-top: 2px;
        }
        
        /* Table */
        .trade-table {
            width: 100%;
            border-collapse: collapse;
        }
        .trade-table th {
            background: rgba(0,0,0,0.3);
            padding: 12px 16px;
            text-align: left;
            font-size: 0.7rem;
            font-weight: 500;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .trade-table th:last-child { text-align: right; }
        .trade-table td {
            padding: 14px 16px;
            border-bottom: 1px solid var(--border-color);
            font-size: 0.875rem;
        }
        .trade-table tr:hover { background: rgba(255,255,255,0.02); }
        
        /* Tags */
        .tag {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: 500;
        }
        .tag.v5 { background: rgba(88,166,255,0.2); color: var(--accent-blue); }
        .tag.kraken { background: rgba(88,166,255,0.2); color: var(--accent-blue); }
        .tag.drift { background: rgba(168,85,247,0.2); color: var(--accent-purple); }
        .tag.long { background: var(--accent-green-dim); color: var(--accent-green); }
        .tag.short { background: var(--accent-red-dim); color: var(--accent-red); }
        .tag.open { background: rgba(255,165,2,0.2); color: #ffa502; }
        
        /* P&L Cell */
        .pnl-cell { text-align: right; }
        .pnl-cell .usd { font-weight: 600; }
        .pnl-cell .usd.positive { color: var(--accent-green); }
        .pnl-cell .usd.negative { color: var(--accent-red); }
        .pnl-cell .pct { font-size: 0.75rem; }
        .pnl-cell .pct.positive { color: rgba(0,255,136,0.7); }
        .pnl-cell .pct.negative { color: rgba(255,71,87,0.7); }
        
        /* Asset Cell */
        .asset-cell .name { font-weight: 500; }
        .asset-cell .exchange { font-size: 0.7rem; color: var(--text-secondary); }
        
        /* Entry/Exit Cell */
        .price-cell .price { }
        .price-cell .time { font-size: 0.7rem; color: var(--text-secondary); }
        
        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 48px;
            color: var(--text-secondary);
        }
        
        /* Systems Status Panel */
        .systems-status {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            padding: 20px 24px;
            margin-bottom: 24px;
        }
        .systems-status.healthy { border-color: rgba(0,255,136,0.3); }
        .systems-status.warning { border-color: rgba(255,165,2,0.3); }
        .systems-status.error { border-color: rgba(255,71,87,0.3); }
        
        .systems-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }
        .systems-header h2 {
            font-size: 1rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .systems-header .status-badge {
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 600;
        }
        .status-badge.healthy { background: var(--accent-green-dim); color: var(--accent-green); }
        .status-badge.warning { background: rgba(255,165,2,0.2); color: #ffa502; }
        .status-badge.error { background: var(--accent-red-dim); color: var(--accent-red); }
        
        .systems-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 12px;
        }
        .system-check {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: rgba(255,255,255,0.03);
            border-radius: 8px;
            font-size: 0.85rem;
        }
        .system-check .indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }
        .system-check .indicator.ok { background: var(--accent-green); box-shadow: 0 0 8px var(--accent-green); }
        .system-check .indicator.warn { background: #ffa502; box-shadow: 0 0 8px #ffa502; }
        .system-check .indicator.error { background: var(--accent-red); box-shadow: 0 0 8px var(--accent-red); }
        .system-check .name { flex: 1; }
        .system-check .detail { color: var(--text-secondary); font-size: 0.75rem; }
        
        .last-executions {
            display: flex;
            gap: 24px;
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid var(--border-color);
            font-size: 0.8rem;
        }
        .execution-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .execution-item .label { color: var(--text-secondary); }
        .execution-item .time { font-weight: 500; }
        .execution-item .time.stale { color: var(--accent-red); }
        
        /* Open Positions Panel */
        .open-positions {
            background: linear-gradient(135deg, #1a2a1a 0%, #162a16 100%);
            border: 2px solid rgba(0,255,136,0.3);
            border-radius: 16px;
            padding: 20px 24px;
            margin-bottom: 24px;
        }
        .open-positions.no-positions {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
        }
        .open-positions-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }
        .open-positions-header h2 {
            font-size: 1.25rem;
            font-weight: 600;
        }
        .position-count {
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 600;
            background: var(--accent-green-dim);
            color: var(--accent-green);
        }
        .position-count.none {
            background: rgba(255,255,255,0.1);
            color: var(--text-secondary);
        }
        .positions-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 16px;
        }
        .position-card {
            background: rgba(0,0,0,0.3);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 16px;
        }
        .position-card.profit { border-left: 3px solid var(--accent-green); }
        .position-card.loss { border-left: 3px solid var(--accent-red); }
        .position-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 12px;
        }
        .position-asset {
            font-size: 1.25rem;
            font-weight: 600;
        }
        .position-exchange {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-top: 2px;
        }
        .strategy-tag {
            font-weight: 600;
            padding: 1px 6px;
            border-radius: 4px;
            font-size: 0.7rem;
        }
        .strategy-tag.v50 {
            background: rgba(88, 166, 255, 0.2);
            color: var(--accent-blue);
        }
        .strategy-tag.ibb {
            background: rgba(168, 85, 247, 0.2);
            color: var(--accent-purple);
        }
        .strategy-tag.lc {
            background: rgba(0, 255, 136, 0.2);
            color: var(--accent-green);
        }
        .strategy-tag.vwap {
            background: rgba(88, 166, 255, 0.15); color: #58a6ff; border-color: rgba(88, 166, 255, 0.3);
        }
        .strategy-tag.momentum {
            background: rgba(255, 165, 2, 0.2);
            color: #ffa502;
        }
        .position-meta {
            display: flex;
            gap: 8px;
            margin-top: 4px;
            align-items: center;
        }
        .entry-date {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-left: auto;
        }
        .position-pnl {
            text-align: right;
        }
        .position-pnl .value {
            font-size: 1.5rem;
            font-weight: 700;
        }
        .position-pnl .value.positive { color: var(--accent-green); }
        .position-pnl .value.negative { color: var(--accent-red); }
        .position-pnl .pct {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }
        .position-details {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 12px;
            padding-top: 12px;
            border-top: 1px solid var(--border-color);
        }
        .position-detail .label {
            font-size: 0.65rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            margin-bottom: 2px;
        }
        .position-detail .value {
            font-size: 0.9rem;
            font-weight: 500;
        }
        .position-detail .value.sl { color: var(--accent-red); }
        .position-detail .value.tp { color: var(--accent-green); }
        .no-positions-msg {
            text-align: center;
            padding: 24px;
            color: var(--text-secondary);
        }
        
        /* Executive Summary */
        .exec-summary {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            padding: 24px;
            margin-bottom: 24px;
        }
        .exec-summary-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        .exec-summary-header h2 {
            font-size: 1.25rem;
            font-weight: 700;
        }
        .exec-summary-header .since {
            color: var(--text-secondary);
            font-size: 0.85rem;
        }
        .exec-kpis {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 16px;
            margin-bottom: 20px;
        }
        .exec-kpi {
            background: rgba(255,255,255,0.03);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 16px;
            text-align: center;
        }
        .exec-kpi .label {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-secondary);
            margin-bottom: 6px;
        }
        .exec-kpi .value {
            font-size: 1.5rem;
            font-weight: 700;
        }
        .exec-kpi .value.positive { color: var(--accent-green); }
        .exec-kpi .value.negative { color: var(--accent-red); }
        .exec-kpi .value.neutral { color: var(--accent-blue); }
        .exec-kpi .sub {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-top: 4px;
        }
        .exec-strategy-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9rem;
        }
        .exec-strategy-table th {
            text-align: left;
            padding: 10px 12px;
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-secondary);
            border-bottom: 1px solid var(--border-color);
        }
        .exec-strategy-table th:not(:first-child) { text-align: right; }
        .exec-strategy-table td {
            padding: 10px 12px;
            border-bottom: 1px solid rgba(255,255,255,0.03);
        }
        .exec-strategy-table td:not(:first-child) { text-align: right; }
        .exec-strategy-table tr:last-child td { border-bottom: none; }
        .exec-strategy-table .total-row td {
            font-weight: 700;
            border-top: 2px solid var(--border-color);
            border-bottom: none;
            padding-top: 14px;
        }
        .exec-bar {
            display: inline-block;
            height: 6px;
            border-radius: 3px;
            margin-right: 8px;
            vertical-align: middle;
        }
        .exec-bar.green { background: var(--accent-green); }
        .exec-bar.red { background: var(--accent-red); }
        
        @media (max-width: 768px) {
            .exec-kpis { grid-template-columns: repeat(3, 1fr); }
        }

        /* Decommissioned */
        .decommissioned {
            background: rgba(255,255,255,0.02);
            border: 1px dashed var(--border-color);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 24px;
            opacity: 0.7;
        }
        .decom-header h3 {
            font-size: 0.95rem;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 12px;
        }
        .decom-items {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
        }
        .decom-item {
            background: rgba(255,255,255,0.03);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            padding: 14px 18px;
            min-width: 200px;
            flex: 1;
        }
        .decom-item .name {
            font-weight: 600;
            font-size: 0.9rem;
            margin-bottom: 4px;
        }
        .decom-item .detail {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }
        .decom-item .status-tag {
            display: inline-block;
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            padding: 2px 8px;
            border-radius: 4px;
            background: rgba(255,165,2,0.15);
            color: #ffa502;
            margin-bottom: 6px;
        }

        /* Equity Curves */
        .equity-section {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            padding: 24px;
            margin-bottom: 24px;
        }
        .equity-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }
        .equity-header h2 { font-size: 1.1rem; font-weight: 600; }
        .equity-legend {
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
        }
        .equity-legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.8rem;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 6px;
            transition: background 0.2s;
        }
        .equity-legend-item:hover { background: rgba(255,255,255,0.05); }
        .equity-legend-item.hidden { opacity: 0.3; }
        .equity-legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }
        .equity-canvas-wrap {
            position: relative;
            width: 100%;
            height: 350px;
        }
        .equity-canvas-wrap canvas {
            width: 100%;
            height: 100%;
        }
        .equity-tooltip {
            position: absolute;
            background: rgba(20,20,35,0.95);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 10px 14px;
            font-size: 0.8rem;
            pointer-events: none;
            display: none;
            z-index: 10;
            min-width: 140px;
        }
        .equity-tooltip .date { color: var(--text-secondary); margin-bottom: 6px; }
        .equity-tooltip .line { display: flex; justify-content: space-between; gap: 12px; margin: 2px 0; }

        /* Pagination */
        .pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
            padding: 16px 20px;
            border-top: 1px solid var(--border-color);
        }
        .pagination button {
            background: rgba(255,255,255,0.05);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 8px 14px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s;
        }
        .pagination button:hover:not(:disabled) {
            background: rgba(88,166,255,0.15);
            border-color: var(--accent-blue);
        }
        .pagination button:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        .pagination button.active {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
            color: #fff;
            font-weight: 600;
        }
        .pagination .page-info {
            color: var(--text-secondary);
            font-size: 0.85rem;
            margin: 0 8px;
        }

        /* Footer */
        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.8rem;
            color: var(--text-secondary);
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            .strategies-grid { grid-template-columns: 1fr; }
            .metrics-grid { grid-template-columns: repeat(2, 1fr); }
            .mini-stats { grid-template-columns: repeat(3, 1fr); }
            .trade-table { font-size: 0.8rem; }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <div>
                <h1>MegaMax Trading Performance</h1>
                <p class="subtitle">V5.0 + IBB + Momentum + LC + VWAP Scalper on Drift Protocol ‚Ä¢ Live trading ‚Ä¢ MegaMax v1.7</p>
            </div>
            <div class="updated" id="lastUpdated">Loading...</div>
        </div>
        
        <!-- Executive Summary -->
        <div class="exec-summary" id="execSummary" style="display:none;">
            <div class="exec-summary-header">
                <h2>üìà Executive Summary ‚Äî All Strategies</h2>
                <span class="since" id="execSince"></span>
            </div>
            <div class="exec-kpis" id="execKpis"></div>
            <table class="exec-strategy-table">
                <thead>
                    <tr>
                        <th>Strategy</th>
                        <th>Trades</th>
                        <th>Win Rate</th>
                        <th>Wins / Losses</th>
                        <th>P&L</th>
                        <th>Avg Trade</th>
                        <th>Best Trade</th>
                        <th>Worst Trade</th>
                        <th>Profit Factor</th>
                    </tr>
                </thead>
                <tbody id="execStrategyBody"></tbody>
            </table>
        </div>

        <!-- Open Positions Panel -->
        <div class="open-positions" id="openPositions">
            <div class="open-positions-header">
                <h2>üìä Open Positions</h2>
                <span class="position-count" id="positionCount">Loading...</span>
            </div>
            <div class="positions-grid" id="positionsGrid">
                <!-- Populated by JS -->
            </div>
        </div>
        
        <!-- System Overview Panel -->
        <div class="systems-status healthy" id="systemsStatus">
            <div class="systems-header">
                <h2>‚ö° MegaMax Drift Trading System</h2>
                <span class="status-badge healthy" id="systemsBadge">LIVE</span>
            </div>
            <div class="systems-grid" id="systemsGrid">
                <div class="system-check">
                    <span class="indicator ok"></span>
                    <span class="name">V5.0 Mean Reversion</span>
                    <span class="detail">SOL, LTC, INJ, PEPE, RNDR ‚Ä¢ Fade breakouts</span>
                </div>
                <div class="system-check">
                    <span class="indicator ok"></span>
                    <span class="name">IBB Inside Bar</span>
                    <span class="detail">DOT, XRP, DOGE, ETH ‚Ä¢ Breakout signals</span>
                </div>
                <div class="system-check">
                    <span class="indicator ok"></span>
                    <span class="name">üöÄ Momentum</span>
                    <span class="detail">BONK, ARB, SUI, WIF, W, RNDR ‚Ä¢ Daily breakouts</span>
                </div>
                <div class="system-check">
                    <span class="indicator ok"></span>
                    <span class="name">üìâ LC (RSI)</span>
                    <span class="detail">RNDR, NEAR, JUP, SOL, DOGE, PYTH, OP ‚Ä¢ RSI(2) mean reversion</span>
                </div>
                <div class="system-check">
                    <span class="indicator ok"></span>
                    <span class="name">‚ö° VWAP Scalper</span>
                    <span class="detail">SOL ‚Ä¢ 30s VWAP band reversion ‚Ä¢ $50/trade</span>
                </div>
            </div>
            <div class="last-executions" id="lastExecutions">
                <div class="execution-item">
                    <span class="label">Last Check:</span>
                    <span class="time" id="lastCheckTime">-</span>
                </div>
                <div class="execution-item">
                    <span class="label">Account:</span>
                    <span class="time" id="accountBalance">$1,880</span>
                </div>
                <div class="execution-item">
                    <span class="label">Cron:</span>
                    <span class="time">Hourly @:05</span>
                </div>
            </div>
        </div>
        
        <!-- Strategy Cards -->
        <div class="strategies-grid" id="strategiesGrid">
            <!-- Populated by JS -->
        </div>
        
        <!-- Equity Curves -->
        <div class="equity-section" id="equitySection" style="display:none;">
            <div class="equity-header">
                <h2>üìà Cumulative P&L by Strategy</h2>
                <div class="equity-legend" id="equityLegend"></div>
            </div>
            <div class="equity-canvas-wrap">
                <canvas id="equityCanvas"></canvas>
                <div class="equity-tooltip" id="equityTooltip"></div>
            </div>
        </div>
        
        <!-- Trade Log -->
        <div class="trade-log">
            <div class="trade-log-header">
                <h2>Trade History</h2>
                <p class="count" id="tradeCount">Loading...</p>
            </div>
            <table class="trade-table">
                <thead>
                    <tr>
                        <th>Strategy</th>
                        <th>Asset</th>
                        <th>Direction</th>
                        <th>Entry</th>
                        <th>Exit</th>
                        <th>Size</th>
                        <th>P&L</th>
                    </tr>
                </thead>
                <tbody id="tradeTableBody">
                    <!-- Populated by JS -->
                </tbody>
            </table>
            <div class="pagination" id="pagination" style="display:none;">
                <button id="prevPage">‚Üê Prev</button>
                <div id="pageNumbers"></div>
                <button id="nextPage">Next ‚Üí</button>
                <span class="page-info" id="pageInfo"></span>
            </div>
        </div>
        
        <!-- Footer -->
        <div class="footer">
            Auto-updated every 5 minutes ‚Ä¢ Trades execute with automatic stop-loss protection
        </div>
    </div>

    <script>
        // ============================================================
        // MegaMax Dashboard v2.0 - Robust Data Loading
        // Loads: state.json (positions/trades) + trading-stats.json (strategy stats)
        // ============================================================
        
        // Utility functions with safe defaults
        function formatCurrency(value) {
            if (value === undefined || value === null || typeof value !== 'number' || isNaN(value)) return '$-';
            const abs = Math.abs(value);
            const formatted = abs >= 1000 ? `$${(abs/1000).toFixed(1)}k` : `$${abs.toFixed(2)}`;
            return value < 0 ? `-${formatted}` : formatted;
        }
        
        function formatPercent(value) {
            if (value === undefined || value === null || typeof value !== 'number' || isNaN(value)) return '-';
            return `${value >= 0 ? '+' : ''}${value.toFixed(2)}%`;
        }
        
        function formatDuration(ms) {
            if (!ms || typeof ms !== 'number' || isNaN(ms)) return '-';
            const hours = ms / (1000 * 60 * 60);
            return hours < 24 ? `${hours.toFixed(1)}h` : `${(hours/24).toFixed(1)}d`;
        }
        
        function formatDate(ts) {
            if (!ts) return '-';
            try {
                const d = new Date(ts);
                if (isNaN(d.getTime())) return '-';
                return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' });
            } catch { return '-'; }
        }
        
        function formatDateShort(ts) {
            if (!ts) return 'N/A';
            try {
                const d = new Date(ts);
                if (isNaN(d.getTime())) return 'N/A';
                return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
            } catch { return 'N/A'; }
        }
        
        function safeNum(val, fallback = 0) {
            return (typeof val === 'number' && !isNaN(val)) ? val : fallback;
        }
        
        // Render strategy card with safe defaults
        function renderStrategyCard(stats) {
            const pnl = safeNum(stats.totalPnlUsd);
            const isProfit = pnl >= 0;
            const winRate = safeNum(stats.winRate);
            const pf = stats.profitFactor;
            const pfDisplay = (!pf || pf === Infinity || pf > 100) ? '‚àû' : safeNum(pf).toFixed(2);
            
            return `
                <div class="strategy-card">
                    <div class="strategy-header">
                        <div>
                            <div class="strategy-name">${stats.strategy || 'Unknown'} Strategy</div>
                            <div class="strategy-since">Since ${formatDateShort(stats.firstTradeTime)}</div>
                        </div>
                        <div class="total-return">
                            <div class="value ${isProfit ? 'positive' : 'negative'}">${formatPercent(stats.totalPnlPercent)}</div>
                            <div class="label">Total Return</div>
                        </div>
                    </div>
                    
                    <div class="metrics-grid">
                        <div class="metric-card">
                            <div class="label">Total P&L</div>
                            <div class="value ${isProfit ? 'positive' : 'negative'}">${formatCurrency(pnl)}</div>
                        </div>
                        <div class="metric-card">
                            <div class="label">Win Rate</div>
                            <div class="value ${winRate >= 50 ? 'positive' : 'negative'}">${winRate.toFixed(1)}%</div>
                        </div>
                        <div class="metric-card">
                            <div class="label">Profit Factor</div>
                            <div class="value ${safeNum(pf, 1) >= 1 ? 'positive' : 'negative'}">${pfDisplay}</div>
                        </div>
                        <div class="metric-card">
                            <div class="label">Max Drawdown</div>
                            <div class="value ${safeNum(stats.maxDrawdownPercent) < 20 ? 'positive' : 'negative'}">-${safeNum(stats.maxDrawdownPercent).toFixed(1)}%</div>
                        </div>
                    </div>
                    
                    <div class="mini-stats">
                        <div class="mini-stat">
                            <div class="label">Trades</div>
                            <div class="value">${safeNum(stats.totalTrades)}</div>
                        </div>
                        <div class="mini-stat">
                            <div class="label">Wins</div>
                            <div class="value">${safeNum(stats.winningTrades)}</div>
                        </div>
                        <div class="mini-stat">
                            <div class="label">Losses</div>
                            <div class="value">${safeNum(stats.losingTrades)}</div>
                        </div>
                        <div class="mini-stat">
                            <div class="label">Avg Win</div>
                            <div class="value">${formatCurrency(stats.avgWinUsd)}</div>
                        </div>
                        <div class="mini-stat">
                            <div class="label">Avg Loss</div>
                            <div class="value">${formatCurrency(stats.avgLossUsd)}</div>
                        </div>
                        <div class="mini-stat">
                            <div class="label">Avg Hold</div>
                            <div class="value">${formatDuration(stats.avgHoldingTimeMs)}</div>
                        </div>
                    </div>
                    
                    <div class="capital-progress">
                        <span class="start">Capital: ${formatCurrency(stats.startingCapital)}</span>
                        <span class="arrow">‚Üí</span>
                        <span class="current">${formatCurrency(stats.currentCapital)}</span>
                    </div>
                </div>
            `;
        }
        
        // Render open position card
        function renderPositionCard(pos) {
            const pnl = safeNum(pos.unrealizedPnl);
            const isProfit = pnl >= 0;
            const pnlClass = isProfit ? 'profit' : 'loss';
            const pnlValueClass = isProfit ? 'positive' : 'negative';
            const strategy = pos.strategy || 'V5.0';
            const strategyClass = strategy === 'IBB' ? 'ibb' : strategy === 'LC' ? 'lc' : strategy === 'MOMENTUM' ? 'momentum' : strategy === 'VWAP-RSI' ? 'vwap' : 'v50';
            const leverage = safeNum(pos.leverage, 5);
            const direction = pos.direction || 'LONG';
            
            return `
                <div class="position-card ${pnlClass}">
                    <div class="position-header">
                        <div>
                            <div class="position-asset">${pos.asset || 'Unknown'}</div>
                            <div class="position-exchange">${pos.exchange || 'Drift'} ‚Ä¢ <span class="strategy-tag ${strategyClass}">${strategy}</span></div>
                            <div class="position-meta">
                                <span class="tag ${direction.toLowerCase()}">${direction} ${leverage}x</span>
                                <span class="entry-date">${formatDate(pos.entryTime)}</span>
                            </div>
                        </div>
                        <div class="position-pnl">
                            <div class="value ${pnlValueClass}">${formatCurrency(pnl)}</div>
                            <div class="pct">${formatPercent(pos.unrealizedPnlPct)}</div>
                        </div>
                    </div>
                    <div class="position-details">
                        <div class="position-detail">
                            <div class="label">Size</div>
                            <div class="value">${formatCurrency(pos.positionSize)}</div>
                        </div>
                        <div class="position-detail">
                            <div class="label">Entry</div>
                            <div class="value">$${safeNum(pos.entryPrice).toLocaleString()}</div>
                        </div>
                        <div class="position-detail">
                            <div class="label">Current</div>
                            <div class="value">$${safeNum(pos.currentPrice).toLocaleString()}</div>
                        </div>
                        <div class="position-detail">
                            <div class="label">Stop Loss</div>
                            <div class="value sl">${pos.stopLoss ? '$' + pos.stopLoss.toLocaleString() : '$-'}</div>
                        </div>
                        <div class="position-detail">
                            <div class="label">Take Profit</div>
                            <div class="value tp">${pos.takeProfit ? '$' + pos.takeProfit.toLocaleString() : '$-'}</div>
                        </div>
                    </div>
                </div>
            `;
        }
        
        // Render trade row
        function renderTradeRow(trade) {
            const isOpen = trade.status === 'OPEN';
            const pnl = safeNum(trade.pnlUsd || trade.pnl);
            const isWin = pnl > 0 || trade.result === 'WIN';
            const strategy = trade.strategy || 'V5.0';
            const direction = trade.direction || 'LONG';
            const leverage = safeNum(trade.leverage, 5);
            
            return `
                <tr>
                    <td><span class="tag drift">${strategy}</span></td>
                    <td class="asset-cell">
                        <div class="name">${trade.asset || 'Unknown'}</div>
                        <div class="exchange">${trade.exchange || 'Drift'}</div>
                    </td>
                    <td><span class="tag ${direction.toLowerCase()}">${direction} ${leverage}x</span></td>
                    <td class="price-cell">
                        <div class="price">$${safeNum(trade.entryPrice).toLocaleString()}</div>
                        <div class="time">${formatDate(trade.entryTime)}</div>
                    </td>
                    <td class="price-cell">
                        ${isOpen ? '<span class="tag open">Open</span>' : `
                            <div class="price">$${safeNum(trade.exitPrice).toLocaleString()}</div>
                            <div class="time">${trade.exitReason || 'Closed'}</div>
                        `}
                    </td>
                    <td>${formatCurrency(trade.positionSize)}</td>
                    <td class="pnl-cell">
                        ${isOpen ? '-' : `
                            <div class="usd ${isWin ? 'positive' : 'negative'}">${formatCurrency(pnl)}</div>
                            <div class="pct ${isWin ? 'positive' : 'negative'}">${formatPercent(trade.pnlPercent)}</div>
                        `}
                    </td>
                </tr>
            `;
        }
        
        // Strategy colors
        const STRAT_COLORS = {
            'V5.0': '#58a6ff',
            'IBB': '#00ff88',
            'LC': '#ffa502',
            'MOMENTUM': '#a855f7',
            'VWAP-RSI': '#ff6b81',
            'ALL': '#ffffff'
        };
        
        // Equity curve renderer
        let equityHiddenStrats = new Set();
        let equityCurveData = null;
        
        function renderEquityCurves(trades) {
            if (!trades || trades.length === 0) return;
            
            document.getElementById('equitySection').style.display = 'block';
            
            // Group trades by date and strategy, compute cumulative P&L
            const byDateStrat = {};
            const strategies = new Set();
            
            // Sort trades by exit time
            const sorted = [...trades].sort((a, b) => {
                const da = new Date(a.exitTime || a.entryTime || 0);
                const db = new Date(b.exitTime || b.entryTime || 0);
                return da - db;
            });
            
            sorted.forEach(t => {
                const exitTime = t.exitTime || t.entryTime;
                if (!exitTime) return;
                const date = new Date(exitTime).toISOString().slice(0, 10);
                const strat = t.strategy || 'Unknown';
                const pnl = safeNum(t.pnlUsd || t.pnl);
                strategies.add(strat);
                
                if (!byDateStrat[date]) byDateStrat[date] = {};
                if (!byDateStrat[date][strat]) byDateStrat[date][strat] = 0;
                byDateStrat[date][strat] += pnl;
                if (!byDateStrat[date]['ALL']) byDateStrat[date]['ALL'] = 0;
                byDateStrat[date]['ALL'] += pnl;
            });
            
            strategies.add('ALL');
            const dates = Object.keys(byDateStrat).sort();
            
            // Build cumulative series
            const cumulative = {};
            [...strategies].forEach(s => { cumulative[s] = []; });
            let running = {};
            [...strategies].forEach(s => { running[s] = 0; });
            
            dates.forEach(date => {
                [...strategies].forEach(s => {
                    running[s] += (byDateStrat[date][s] || 0);
                    cumulative[s].push({ date, value: running[s] });
                });
            });
            
            equityCurveData = { dates, cumulative, strategies: [...strategies] };
            
            // Render legend
            const legend = document.getElementById('equityLegend');
            legend.innerHTML = [...strategies].map(s => `
                <div class="equity-legend-item" data-strat="${s}" onclick="toggleEquityStrat('${s}')">
                    <div class="equity-legend-dot" style="background:${STRAT_COLORS[s] || '#888'}"></div>
                    <span>${s}</span>
                </div>
            `).join('');
            
            drawEquityChart();
        }
        
        function toggleEquityStrat(strat) {
            if (equityHiddenStrats.has(strat)) {
                equityHiddenStrats.delete(strat);
            } else {
                equityHiddenStrats.add(strat);
            }
            document.querySelectorAll('.equity-legend-item').forEach(el => {
                el.classList.toggle('hidden', equityHiddenStrats.has(el.dataset.strat));
            });
            drawEquityChart();
        }
        
        function drawEquityChart() {
            if (!equityCurveData) return;
            const { dates, cumulative, strategies } = equityCurveData;
            
            const canvas = document.getElementById('equityCanvas');
            const wrap = canvas.parentElement;
            const dpr = window.devicePixelRatio || 1;
            canvas.width = wrap.clientWidth * dpr;
            canvas.height = wrap.clientHeight * dpr;
            const ctx = canvas.getContext('2d');
            ctx.scale(dpr, dpr);
            const W = wrap.clientWidth;
            const H = wrap.clientHeight;
            
            const pad = { top: 20, right: 20, bottom: 40, left: 65 };
            const chartW = W - pad.left - pad.right;
            const chartH = H - pad.top - pad.bottom;
            
            // Find min/max across visible strategies
            let allVals = [];
            strategies.forEach(s => {
                if (equityHiddenStrats.has(s)) return;
                cumulative[s].forEach(p => allVals.push(p.value));
            });
            if (allVals.length === 0) allVals = [0];
            
            const minVal = Math.min(0, Math.min(...allVals));
            const maxVal = Math.max(0, Math.max(...allVals));
            const range = maxVal - minVal || 1;
            const padding = range * 0.1;
            const yMin = minVal - padding;
            const yMax = maxVal + padding;
            
            const xScale = (i) => pad.left + (i / Math.max(dates.length - 1, 1)) * chartW;
            const yScale = (v) => pad.top + chartH - ((v - yMin) / (yMax - yMin)) * chartH;
            
            // Clear
            ctx.clearRect(0, 0, W, H);
            
            // Grid lines
            ctx.strokeStyle = 'rgba(255,255,255,0.06)';
            ctx.lineWidth = 1;
            const gridLines = 5;
            for (let i = 0; i <= gridLines; i++) {
                const v = yMin + (yMax - yMin) * (i / gridLines);
                const y = yScale(v);
                ctx.beginPath();
                ctx.moveTo(pad.left, y);
                ctx.lineTo(W - pad.right, y);
                ctx.stroke();
                
                // Y label
                ctx.fillStyle = '#888';
                ctx.font = '11px -apple-system, sans-serif';
                ctx.textAlign = 'right';
                ctx.fillText('$' + v.toFixed(0), pad.left - 8, y + 4);
            }
            
            // Zero line
            if (yMin < 0 && yMax > 0) {
                ctx.strokeStyle = 'rgba(255,255,255,0.15)';
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.moveTo(pad.left, yScale(0));
                ctx.lineTo(W - pad.right, yScale(0));
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            // X labels (dates)
            ctx.fillStyle = '#888';
            ctx.font = '11px -apple-system, sans-serif';
            ctx.textAlign = 'center';
            const maxLabels = Math.min(dates.length, 10);
            const step = Math.max(1, Math.floor(dates.length / maxLabels));
            dates.forEach((d, i) => {
                if (i % step === 0 || i === dates.length - 1) {
                    const x = xScale(i);
                    const label = d.slice(5); // MM-DD
                    ctx.fillText(label, x, H - pad.bottom + 20);
                    
                    ctx.strokeStyle = 'rgba(255,255,255,0.04)';
                    ctx.beginPath();
                    ctx.moveTo(x, pad.top);
                    ctx.lineTo(x, H - pad.bottom);
                    ctx.stroke();
                }
            });
            
            // Draw lines (ALL first so it's behind)
            const drawOrder = ['ALL', ...strategies.filter(s => s !== 'ALL')];
            drawOrder.forEach(strat => {
                if (equityHiddenStrats.has(strat)) return;
                const points = cumulative[strat];
                if (!points || points.length < 2) return;
                
                const color = STRAT_COLORS[strat] || '#888';
                const isAll = strat === 'ALL';
                
                ctx.strokeStyle = color;
                ctx.lineWidth = isAll ? 3 : 2;
                ctx.globalAlpha = isAll ? 0.4 : 0.9;
                ctx.lineJoin = 'round';
                ctx.lineCap = 'round';
                
                // Line
                ctx.beginPath();
                points.forEach((p, i) => {
                    const x = xScale(i);
                    const y = yScale(p.value);
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.stroke();
                
                // Gradient fill for ALL
                if (isAll) {
                    const gradient = ctx.createLinearGradient(0, pad.top, 0, H - pad.bottom);
                    gradient.addColorStop(0, 'rgba(255,255,255,0.06)');
                    gradient.addColorStop(1, 'rgba(255,255,255,0)');
                    ctx.fillStyle = gradient;
                    ctx.lineTo(xScale(points.length - 1), yScale(yMin));
                    ctx.lineTo(xScale(0), yScale(yMin));
                    ctx.closePath();
                    ctx.fill();
                }
                
                // Dots on data points
                if (!isAll) {
                    points.forEach((p, i) => {
                        ctx.beginPath();
                        ctx.arc(xScale(i), yScale(p.value), 3, 0, Math.PI * 2);
                        ctx.fillStyle = color;
                        ctx.globalAlpha = 0.8;
                        ctx.fill();
                    });
                }
                
                // Label at end
                const last = points[points.length - 1];
                ctx.fillStyle = color;
                ctx.globalAlpha = 1;
                ctx.font = `${isAll ? 'bold ' : ''}11px -apple-system, sans-serif`;
                ctx.textAlign = 'left';
                const labelX = xScale(points.length - 1) + 6;
                const labelY = yScale(last.value) + 4;
                ctx.fillText(`${strat} $${last.value.toFixed(0)}`, Math.min(labelX, W - 80), labelY);
                
                ctx.globalAlpha = 1;
            });
            
            // Hover tooltip
            canvas.onmousemove = (e) => {
                const rect = canvas.getBoundingClientRect();
                const mx = e.clientX - rect.left;
                const my = e.clientY - rect.top;
                
                if (mx < pad.left || mx > W - pad.right || my < pad.top || my > H - pad.bottom) {
                    document.getElementById('equityTooltip').style.display = 'none';
                    return;
                }
                
                const idx = Math.round(((mx - pad.left) / chartW) * (dates.length - 1));
                const clampIdx = Math.max(0, Math.min(idx, dates.length - 1));
                const date = dates[clampIdx];
                
                let html = `<div class="date">${date}</div>`;
                strategies.forEach(s => {
                    if (equityHiddenStrats.has(s)) return;
                    const val = cumulative[s][clampIdx]?.value || 0;
                    const color = STRAT_COLORS[s] || '#888';
                    html += `<div class="line"><span style="color:${color}">${s}</span><span style="color:${val >= 0 ? '#00ff88' : '#ff4757'}">${formatCurrency(val)}</span></div>`;
                });
                
                const tooltip = document.getElementById('equityTooltip');
                tooltip.innerHTML = html;
                tooltip.style.display = 'block';
                tooltip.style.left = Math.min(mx + 12, W - 170) + 'px';
                tooltip.style.top = (my - 10) + 'px';
            };
            
            canvas.onmouseleave = () => {
                document.getElementById('equityTooltip').style.display = 'none';
            };
        }
        
        // Redraw on resize
        window.addEventListener('resize', () => { if (equityCurveData) drawEquityChart(); });
        
        // Executive Summary renderer
        function renderExecSummary(trades, state) {
            if (!trades || trades.length === 0) return;
            
            const summary = document.getElementById('execSummary');
            summary.style.display = 'block';
            
            // Calculate aggregate stats
            const stratStats = {};
            let totalPnl = 0, totalWins = 0, totalLosses = 0;
            let allPnls = [];
            let firstDate = null, lastDate = null;
            let grossWins = 0, grossLosses = 0;
            
            trades.forEach(t => {
                const strat = t.strategy || 'Unknown';
                if (!stratStats[strat]) {
                    stratStats[strat] = { wins: 0, losses: 0, pnl: 0, pnls: [], grossWin: 0, grossLoss: 0 };
                }
                
                const pnl = safeNum(t.pnlUsd || t.pnl);
                stratStats[strat].pnl += pnl;
                stratStats[strat].pnls.push(pnl);
                totalPnl += pnl;
                allPnls.push(pnl);
                
                if (pnl > 0) {
                    stratStats[strat].wins++;
                    stratStats[strat].grossWin += pnl;
                    totalWins++;
                    grossWins += pnl;
                } else {
                    stratStats[strat].losses++;
                    stratStats[strat].grossLoss += Math.abs(pnl);
                    totalLosses++;
                    grossLosses += Math.abs(pnl);
                }
                
                const d = new Date(t.entryTime);
                if (d && (!firstDate || d < firstDate)) firstDate = d;
                if (d && (!lastDate || d > lastDate)) lastDate = d;
            });
            
            const totalTrades = trades.length;
            const winRate = totalTrades > 0 ? (totalWins / totalTrades * 100) : 0;
            const avgTrade = totalTrades > 0 ? totalPnl / totalTrades : 0;
            const profitFactor = grossLosses > 0 ? (grossWins / grossLosses) : grossWins > 0 ? Infinity : 0;
            const pfDisplay = profitFactor === Infinity || profitFactor > 100 ? '‚àû' : profitFactor.toFixed(2);
            
            // Max drawdown (running)
            let peak = 0, maxDD = 0, running = 0;
            allPnls.forEach(p => {
                running += p;
                if (running > peak) peak = running;
                const dd = peak - running;
                if (dd > maxDD) maxDD = dd;
            });
            
            const equity = safeNum(state.account?.equity, 0);
            const startingEquity = safeNum(state.account?.startingEquity, 1868.46);
            const totalReturn = startingEquity > 0 ? ((equity - startingEquity) / startingEquity * 100) : 0;
            
            // Days trading
            const days = firstDate && lastDate ? Math.max(1, Math.ceil((lastDate - firstDate) / (1000*60*60*24))) : 1;
            
            // Since date
            document.getElementById('execSince').textContent = firstDate 
                ? `${totalTrades} trades over ${days} days ‚Ä¢ Since ${firstDate.toLocaleDateString('en-US', {month:'short', day:'numeric', year:'numeric'})}`
                : '';
            
            // KPI cards
            document.getElementById('execKpis').innerHTML = `
                <div class="exec-kpi">
                    <div class="label">Total P&L</div>
                    <div class="value ${totalPnl >= 0 ? 'positive' : 'negative'}">${formatCurrency(totalPnl)}</div>
                    <div class="sub">${totalReturn >= 0 ? '+' : ''}${totalReturn.toFixed(1)}% return</div>
                </div>
                <div class="exec-kpi">
                    <div class="label">Win Rate</div>
                    <div class="value ${winRate >= 50 ? 'positive' : 'negative'}">${winRate.toFixed(1)}%</div>
                    <div class="sub">${totalWins}W / ${totalLosses}L</div>
                </div>
                <div class="exec-kpi">
                    <div class="label">Total Trades</div>
                    <div class="value neutral">${totalTrades}</div>
                    <div class="sub">${(totalTrades / days).toFixed(1)} / day</div>
                </div>
                <div class="exec-kpi">
                    <div class="label">Avg Trade</div>
                    <div class="value ${avgTrade >= 0 ? 'positive' : 'negative'}">${formatCurrency(avgTrade)}</div>
                    <div class="sub">per trade</div>
                </div>
                <div class="exec-kpi">
                    <div class="label">Profit Factor</div>
                    <div class="value ${profitFactor >= 1 ? 'positive' : 'negative'}">${pfDisplay}</div>
                    <div class="sub">win$ / loss$</div>
                </div>
                <div class="exec-kpi">
                    <div class="label">Max Drawdown</div>
                    <div class="value negative">${formatCurrency(maxDD)}</div>
                    <div class="sub">${startingEquity > 0 ? (maxDD/startingEquity*100).toFixed(1) : 0}% of capital</div>
                </div>
            `;
            
            // Strategy breakdown table
            const sortedStrats = Object.entries(stratStats).sort((a,b) => b[1].pnl - a[1].pnl);
            let tableHtml = '';
            
            sortedStrats.forEach(([name, s]) => {
                const t = s.wins + s.losses;
                const wr = t > 0 ? (s.wins / t * 100) : 0;
                const avg = t > 0 ? s.pnl / t : 0;
                const best = s.pnls.length > 0 ? Math.max(...s.pnls) : 0;
                const worst = s.pnls.length > 0 ? Math.min(...s.pnls) : 0;
                const pf = s.grossLoss > 0 ? (s.grossWin / s.grossLoss) : s.grossWin > 0 ? Infinity : 0;
                const pfStr = pf === Infinity || pf > 100 ? '‚àû' : pf.toFixed(2);
                const wrBarWidth = Math.max(wr * 0.6, 2);
                
                tableHtml += `<tr>
                    <td><strong>${name}</strong></td>
                    <td>${t}</td>
                    <td>
                        <span class="exec-bar green" style="width:${wrBarWidth}px"></span>
                        <span class="${wr >= 50 ? 'positive' : 'negative'}">${wr.toFixed(1)}%</span>
                    </td>
                    <td>${s.wins} / ${s.losses}</td>
                    <td class="${s.pnl >= 0 ? 'positive' : 'negative'}"><strong>${formatCurrency(s.pnl)}</strong></td>
                    <td class="${avg >= 0 ? 'positive' : 'negative'}">${formatCurrency(avg)}</td>
                    <td class="positive">${formatCurrency(best)}</td>
                    <td class="negative">${formatCurrency(worst)}</td>
                    <td class="${pf >= 1 ? 'positive' : 'negative'}">${pfStr}</td>
                </tr>`;
            });
            
            // Total row
            const pfTotal = grossLosses > 0 ? (grossWins / grossLosses) : grossWins > 0 ? Infinity : 0;
            const pfTotalStr = pfTotal === Infinity || pfTotal > 100 ? '‚àû' : pfTotal.toFixed(2);
            const bestAll = allPnls.length > 0 ? Math.max(...allPnls) : 0;
            const worstAll = allPnls.length > 0 ? Math.min(...allPnls) : 0;
            
            tableHtml += `<tr class="total-row">
                <td>ALL STRATEGIES</td>
                <td>${totalTrades}</td>
                <td>
                    <span class="exec-bar green" style="width:${Math.max(winRate * 0.6, 2)}px"></span>
                    <span class="${winRate >= 50 ? 'positive' : 'negative'}">${winRate.toFixed(1)}%</span>
                </td>
                <td>${totalWins} / ${totalLosses}</td>
                <td class="${totalPnl >= 0 ? 'positive' : 'negative'}"><strong>${formatCurrency(totalPnl)}</strong></td>
                <td class="${avgTrade >= 0 ? 'positive' : 'negative'}">${formatCurrency(avgTrade)}</td>
                <td class="positive">${formatCurrency(bestAll)}</td>
                <td class="negative">${formatCurrency(worstAll)}</td>
                <td class="${pfTotal >= 1 ? 'positive' : 'negative'}">${pfTotalStr}</td>
            </tr>`;
            
            document.getElementById('execStrategyBody').innerHTML = tableHtml;
        }
        
        // Pagination state
        const TRADES_PER_PAGE = 30;
        let currentPage = 1;
        let allClosedTrades = [];
        
        function renderTradePage(page) {
            currentPage = page;
            const total = allClosedTrades.length;
            const totalPages = Math.ceil(total / TRADES_PER_PAGE);
            const start = (page - 1) * TRADES_PER_PAGE;
            const end = Math.min(start + TRADES_PER_PAGE, total);
            const pageTrades = allClosedTrades.slice(start, end);
            
            const tbody = document.getElementById('tradeTableBody');
            tbody.innerHTML = pageTrades.map(t => renderTradeRow(t)).join('');
            
            // Update pagination controls
            const pagination = document.getElementById('pagination');
            pagination.style.display = totalPages > 1 ? 'flex' : 'none';
            
            document.getElementById('prevPage').disabled = page <= 1;
            document.getElementById('nextPage').disabled = page >= totalPages;
            document.getElementById('pageInfo').textContent = `${start + 1}‚Äì${end} of ${total}`;
            
            // Page numbers
            const pageNums = document.getElementById('pageNumbers');
            let numsHtml = '';
            for (let i = 1; i <= totalPages; i++) {
                if (i === 1 || i === totalPages || (i >= page - 2 && i <= page + 2)) {
                    numsHtml += `<button class="${i === page ? 'active' : ''}" onclick="renderTradePage(${i})">${i}</button>`;
                } else if (i === page - 3 || i === page + 3) {
                    numsHtml += `<span class="page-info">...</span>`;
                }
            }
            pageNums.innerHTML = numsHtml;
        }
        
        document.getElementById('prevPage').addEventListener('click', () => renderTradePage(currentPage - 1));
        document.getElementById('nextPage').addEventListener('click', () => renderTradePage(currentPage + 1));
        
        // Main data loader - fetches both state.json and trading-stats.json
        async function loadData() {
            const cacheBust = Date.now();
            let state = null;
            let strategyStats = [];
            let errors = [];
            
            // Fetch state.json (positions + trades)
            try {
                const stateRes = await fetch(`state.json?v=${cacheBust}`);
                if (stateRes.ok) {
                    state = await stateRes.json();
                } else {
                    errors.push(`state.json: ${stateRes.status}`);
                }
            } catch (e) {
                errors.push(`state.json: ${e.message}`);
            }
            
            // Fetch trading-stats.json (strategy performance)
            try {
                const statsRes = await fetch(`trading-stats.json?v=${cacheBust}`);
                if (statsRes.ok) {
                    strategyStats = await statsRes.json();
                }
            } catch (e) {
                // Stats file optional - compute from trades if missing
            }
            
            // Fetch trade history ‚Äî prefer trade-log.json (source of truth), fall back to trading-trades.json
            let tradeHistoryData = [];
            try {
                const logRes = await fetch(`trade-log.json?v=${cacheBust}`);
                if (logRes.ok) {
                    const logData = await logRes.json();
                    const allLogTrades = logData.trades || logData;
                    // Convert trade-log format to dashboard format (only closed trades)
                    tradeHistoryData = allLogTrades.filter(t => t.status === 'CLOSED').map(t => ({
                        id: t.id,
                        asset: t.symbol,
                        strategy: t.strategy,
                        direction: t.direction,
                        status: 'CLOSED',
                        entryPrice: t.entry?.price,
                        exitPrice: t.exit?.price,
                        entryTime: t.entry?.time || t.timestamp,
                        exitTime: t.exit?.time,
                        leverage: t.leverage || 5,
                        positionSize: t.positionSize || 200,
                        pnl: t.pnl?.netPnl ?? 0,
                        pnlPercent: t.pnl?.pnlPercent ?? 0,
                        result: (t.pnl?.netPnl ?? 0) > 0 ? 'WIN' : 'LOSS'
                    }));
                    console.log(`Loaded ${tradeHistoryData.length} trades from trade-log.json`);
                }
            } catch (e) {
                console.log('trade-log.json failed, trying trading-trades.json');
            }
            // Fallback to trading-trades.json
            if (tradeHistoryData.length === 0) {
                try {
                    const tradesRes = await fetch(`trading-trades.json?v=${cacheBust}`);
                    if (tradesRes.ok) {
                        tradeHistoryData = await tradesRes.json();
                    }
                } catch (e) { }
            }
            
            // If state.json failed completely, show error
            if (!state) {
                document.getElementById('lastUpdated').textContent = 'Error loading data';
                document.getElementById('lastUpdated').style.color = '#ff4757';
                document.getElementById('positionCount').textContent = 'Error';
                document.getElementById('tradeCount').textContent = errors.join(', ');
                return;
            }
            
            // === RENDER OPEN POSITIONS ===
            const openPositions = (state.openPositions || []).map(p => ({
                asset: p.symbol || p.asset,
                exchange: p.exchange || 'Drift',  // Use actual exchange from data
                strategy: p.strategy || 'V5.0',
                direction: p.direction || 'LONG',
                leverage: p.leverage || 5,
                entryPrice: p.entry || p.entryPrice,
                currentPrice: p.current || p.currentPrice,
                stopLoss: p.stop || p.stopLoss || null,
                takeProfit: p.target || p.takeProfit || null,
                positionSize: p.size || p.positionSize,
                unrealizedPnl: p.pnl || p.unrealizedPnl,
                unrealizedPnlPct: p.pnlPercent || p.unrealizedPnlPct,
                entryTime: p.entryTime || state.lastUpdate
            }));
            renderOpenPositions(openPositions);
            
            // === RENDER STRATEGY CARDS ===
            // Use trading-stats.json if available, otherwise create defaults
            const defaultStrategies = ['V5.0', 'IBB', 'LC', 'MOMENTUM', 'VWAP-RSI'];
            const statsMap = {};
            
            // Initialize with defaults
            defaultStrategies.forEach(s => {
                statsMap[s] = {
                    strategy: s,
                    totalTrades: 0,
                    winningTrades: 0,
                    losingTrades: 0,
                    winRate: 0,
                    totalPnlUsd: 0,
                    totalPnlPercent: 0,
                    avgWinUsd: 0,
                    avgLossUsd: 0,
                    profitFactor: 0,
                    maxDrawdownPercent: 0,
                    avgHoldingTimeMs: 0,
                    startingCapital: state.account?.startingEquity || 1868.46,
                    currentCapital: state.account?.equity || 2076,
                    firstTradeTime: null
                };
            });
            
            // Merge loaded stats
            strategyStats.forEach(s => {
                if (s.strategy) {
                    statsMap[s.strategy] = { ...statsMap[s.strategy], ...s };
                }
            });
            
            // Compute stats from trades if stats file is empty/missing
            const allTrades = state.recentTrades || [];
            if (allTrades.length > 0) {
                allTrades.forEach(t => {
                    const strat = t.strategy || 'V5.0';
                    if (!statsMap[strat]) {
                        statsMap[strat] = { ...statsMap['V5.0'], strategy: strat };
                    }
                    if (t.status === 'CLOSED') {
                        statsMap[strat].totalTrades++;
                        const pnl = t.pnl || 0;
                        statsMap[strat].totalPnlUsd += pnl;
                        if (pnl > 0) statsMap[strat].winningTrades++;
                        else statsMap[strat].losingTrades++;
                        
                        if (!statsMap[strat].firstTradeTime || new Date(t.entryTime) < new Date(statsMap[strat].firstTradeTime)) {
                            statsMap[strat].firstTradeTime = t.entryTime;
                        }
                    }
                });
                
                // Calculate derived stats
                Object.values(statsMap).forEach(s => {
                    if (s.totalTrades > 0) {
                        s.winRate = (s.winningTrades / s.totalTrades) * 100;
                        s.totalPnlPercent = (s.totalPnlUsd / s.startingCapital) * 100;
                    }
                });
            }
            
            // Split active vs decommissioned strategies
            const decommissionedNames = []; // Add strategy names here when retired
            const activeStrategies = Object.values(statsMap).filter(s => 
                !decommissionedNames.includes(s.strategy) && 
                (s.totalTrades > 0 || ['V5.0', 'IBB', 'LC', 'MOMENTUM', 'VWAP-RSI'].includes(s.strategy))
            );
            const decomStrategies = Object.values(statsMap).filter(s => 
                decommissionedNames.includes(s.strategy) || 
                (s.totalTrades === 0 && !['V5.0', 'IBB', 'LC', 'VWAP-RSI'].includes(s.strategy))
            );
            
            const grid = document.getElementById('strategiesGrid');
            grid.innerHTML = activeStrategies.map(s => renderStrategyCard(s)).join('');
            
            // Render decommissioned
            if (decomStrategies.length > 0) {
                const decomEl = document.getElementById('decommissioned');
                decomEl.style.display = 'block';
                document.getElementById('decomBody').innerHTML = `<div class="decom-items">${decomStrategies.map(s => `
                    <div class="decom-item">
                        <span class="status-tag">Decommissioned</span>
                        <div class="name">${s.strategy} Strategy</div>
                        <div class="detail">${s.totalTrades} trades ‚Ä¢ P&L: ${formatCurrency(s.totalPnlUsd)} ‚Ä¢ WR: ${s.totalTrades > 0 ? s.winRate.toFixed(0) : 0}%</div>
                        <div class="detail" style="margin-top:2px;font-style:italic;">Replaced by active strategies</div>
                    </div>
                `).join('')}</div>`;
            }
            
            // === RENDER TRADE HISTORY ===
            // Combine trades from state.recentTrades + trade history
            // tradeHistoryData is already normalized (from trade-log.json or trading-trades.json)
            // allTrades from state.recentTrades needs normalization
            const normalizedStateRecent = allTrades
                .filter(t => t.status === 'CLOSED' || (!t.status && t.exit))
                .map(t => {
                    // Handle pnl being either a number or an object {netPnl, pnlPercent}
                    const pnlVal = typeof t.pnl === 'object' ? (t.pnl?.netPnl ?? 0) : (t.pnl || 0);
                    const pnlPct = typeof t.pnl === 'object' ? (t.pnl?.pnlPercent ?? 0) : (t.pnlPercent || 0);
                    return {
                        strategy: t.strategy || 'V5.0',
                        asset: t.symbol || t.asset,
                        exchange: t.exchange || 'Drift',
                        direction: t.direction || 'LONG',
                        leverage: t.leverage || 5,
                        entryPrice: typeof t.entry === 'object' ? t.entry?.price : (t.entry || t.entryPrice),
                        exitPrice: typeof t.exit === 'object' ? t.exit?.price : (t.exit || t.exitPrice),
                        entryTime: t.entryTime || t.entry?.time || t.timestamp,
                        exitTime: t.exitTime || t.exit?.time,
                        exitReason: t.exitReason || (pnlVal > 0 ? 'TP' : 'SL'),
                        positionSize: t.size || t.positionSize || 375,
                        pnl: pnlVal,
                        pnlPercent: pnlPct,
                        result: t.result || (pnlVal > 0 ? 'WIN' : 'LOSS'),
                        status: t.status || 'CLOSED'
                    };
                });
            
            // Deduplicate by preferring tradeHistoryData (more complete)
            const historyIds = new Set(tradeHistoryData.map(t => t.id));
            const uniqueRecent = normalizedStateRecent.filter(t => !t.id || !historyIds.has(t.id));
            const closedTrades = [...uniqueRecent, ...tradeHistoryData];
            
            // Store globally and render first page
            allClosedTrades = closedTrades;
            if (closedTrades.length === 0) {
                document.getElementById('tradeTableBody').innerHTML = '<tr><td colspan="7" class="empty-state">No closed trades yet</td></tr>';
            } else {
                renderTradePage(1);
            }
            
            // === RENDER EXECUTIVE SUMMARY ===
            renderExecSummary(closedTrades, state);
            
            // === RENDER EQUITY CURVES ===
            renderEquityCurves(closedTrades);
            
            // === UPDATE HEADER INFO ===
            const totalWins = closedTrades.filter(t => t.pnlUsd > 0 || t.result === 'WIN').length;
            const winRate = closedTrades.length > 0 ? Math.round((totalWins / closedTrades.length) * 100) : 0;
            document.getElementById('tradeCount').textContent = `${closedTrades.length} closed trades ‚Ä¢ Win rate: ${winRate}%`;
            
            // Update timestamp
            const updateTime = state.lastUpdate ? new Date(state.lastUpdate) : new Date();
            document.getElementById('lastUpdated').textContent = `Updated ${updateTime.toLocaleString()}`;
            document.getElementById('lastUpdated').style.color = '';
            
            // Update account balance display
            const balanceEl = document.getElementById('accountBalance');
            if (balanceEl && state.account?.equity) {
                balanceEl.textContent = `$${state.account.equity.toFixed(0)}`;
            }
            
            const checkTimeEl = document.getElementById('lastCheckTime');
            if (checkTimeEl) {
                checkTimeEl.textContent = updateTime.toLocaleTimeString();
            }
        }
        
        // Render open positions
        function renderOpenPositions(positions) {
            const panel = document.getElementById('openPositions');
            const countBadge = document.getElementById('positionCount');
            const grid = document.getElementById('positionsGrid');
            
            if (!positions || positions.length === 0) {
                panel.className = 'open-positions no-positions';
                countBadge.className = 'position-count none';
                countBadge.textContent = 'No Open Positions';
                grid.innerHTML = '<div class="no-positions-msg">All flat ‚Äî watching for signals...</div>';
                return;
            }
            
            panel.className = 'open-positions';
            countBadge.className = 'position-count';
            countBadge.textContent = `${positions.length} Position${positions.length > 1 ? 's' : ''} Open`;
            grid.innerHTML = positions.map(p => renderPositionCard(p)).join('');
        }
        
        // Initial load
        loadData();
        
        // Auto-refresh every 5 minutes
        setInterval(loadData, 300000);
    </script>
    
    <!-- Drift Account Link -->
    <div class="container" style="margin-top: 32px; margin-bottom: 32px; text-align: center;">
        <a href="https://app.drift.trade/?authority=3gPExFYHC8fqkwwrb6De8n9fwYdbJPBG3XYLstKNNkt7" 
           target="_blank" 
           style="display: inline-block; background: linear-gradient(135deg, #1a1a2e 0%, #16162a 100%); border: 1px solid var(--border-color); border-radius: 12px; padding: 16px 32px; color: var(--accent-blue); text-decoration: none; font-size: 1rem; font-weight: 500;">
            üìä View Drift Account ‚Üí Open Positions & Orders
        </a>
        <div style="margin-top: 8px; color: var(--text-secondary); font-size: 0.75rem;">
            Wallet: 3gPExFYHC8fqkwwrb6De8n9fwYdbJPBG3XYLstKNNkt7
        </div>
    </div>
</body>
</html>
